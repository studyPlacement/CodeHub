class Solution {
    int arr[];
    public int climbStairs(int n, int[] costs) {
        int dp[] = new int[n+1];
        arr = new int[n+1];
        for(int i=0; i<costs.length; i++){
            arr[i+1] = costs[i];
        }
        dp[0] = 0;
            dp[1] = cost(0, 1);
        if(n == 1){
            return dp[1];
        }
        dp[2] = Math.min(dp[1] + cost(1, 2), cost(0, 2));
        for(int i=3; i<=n; i++){
            int x = cost(i-1, i);
            int y = cost(i-2, i);
            int z = cost(i-3, i);
            dp[i] = Math.min(dp[i-1] + x, Math.min(dp[i-2] + y, dp[i-3] + z));
        }
        return dp[n];
    }
    public int cost(int i, int j){
        return arr[j] + (j-i)*(j-i);
    }
}

Recursion + Memo---------------------------------------------------------------------------------------

class Solution {
    int[] arr;
    int[] dp;

    public int climbStairs(int n, int[] costs) {
        arr = new int[n + 1];
        dp = new int[n + 1];
        Arrays.fill(dp, -1);
        for (int i = 0; i < costs.length; i++) {
            arr[i + 1] = costs[i];
        }
        return solve(n);
    }

    public int solve(int n) {
        if (n == 0) return 0;
        if (n == 1) return cost(0, 1);
        if (n == 2) return Math.min(solve(1) + cost(1, 2), cost(0, 2));
        if (dp[n] != -1) return dp[n];
        int x = solve(n - 1) + cost(n - 1, n);
        int y = solve(n - 2) + cost(n - 2, n);
        int z = solve(n - 3) + cost(n - 3, n);
        return dp[n] = Math.min(x, Math.min(y, z));
    }

    public int cost(int i, int j) {
        return arr[j] + (j - i) * (j - i);
    }
}

